# 4.17 15点数据结构

# 模块一 线性结构

![image-20230417150835574](数据结构笔记.assets/image-20230417150835574.png)

![image-20230417150939043](数据结构笔记.assets/image-20230417150939043.png)

- java中容器和数据结构**相关知识**：

  ​	Iterator接口、	Map、	哈希表



## 数据结构概述

- **定义：** 如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器

  ​		（内存）中，以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行相应操作，这个相应的操作称为算法。

  - 特定的数据类型： 个体如何存储
  - 特定的存储结构： 个体间的关系   



**数据结构**： 个体 + 个体的关系

**算法：** 对存储数据的操作

​		解题方法和步骤

## **衡量算法的标准** 

- 时间复杂度  （程序执行的次数, 运行所需步骤 ）
- 空间复杂度 （算法执行过程中所占用的最大内存）
- 难易程度
- 健壮性



**数据结构的地位**： 是软件中**最核心**的课程 

- 程序： 数据的存储 + 数据的操作 + 可以被计算机执行的语言



**预备知识** ： 指针  结构体  动态内存的分配与释放

- [ ] ![image-20230417165052668](数据结构笔记.assets/image-20230417165052668.png)

- **地址线：** 找到所要进行处理的地址 (地址范围和机器的位数有关系，2的n次方)
- **控制线：** 操作的范围， 只读/ 只写 / 读并写
- **数据线：** 传入数据的方向， a-b / b-a



 ![image-20230417165527094](数据结构笔记.assets/image-20230417165527094.png)

![image-20230417172752381](数据结构笔记.assets/image-20230417172752381.png)

##   一维整型数组

a[0]:  a数组名表示 数组内第一个元素，所占字节数的首地址，但是在调用或使用时，*a == a[0] 会自动截取整个元素（获取其全部字节数），最终显示出**整个元素**



在32位的操作系统中： 一个指针变量（任意类型）的地址所占为4个字节

​	指针变量只存储所指向数据类型的地址（n个字节） 所占字节数第一个字节（8位）的地址

​		当使用此地址进行引用时，指针会自动识别该数据类型提取整个数据



## 指针数组和数组指针的概念

**指针数组**：指针数组是一个数组，是指由指针构成的数组，在这个数组中的所有元素都是指针，每个指针**占用相同**的字节

**数组指针**：数组指针是一个指针，是指一个数组的指针，数组两字表示这个指针指向一个数组的首地址，并且这个**指针加1时移动**的位置是整个数组的长度



## 指向数组的指针代码块及理解

![image-20230417232020822](数据结构笔记.assets/image-20230417232020822.png)

![image-20230417232024013](数据结构笔记.assets/image-20230417232024013.png)

![image-20230417232757151](数据结构笔记.assets/image-20230417232757151.png)

​	**解决**: 内部的*号表示 获取整型数组第一个元素的地址，所以后面的+2，会**根据前面元素的类型** 变成加两个整型数据的字节数，所以变成第三个元素的地址，所以* ***内部**等于第三个元素的值

## 结构体的复习

```c++
#include<stdio.h>
#include<string.h>

struct Student{
	int sid;
	char name[200];
	int age;
};
//提前声明， main后定义了两个方法（在后面需要声明） 
void g(struct Student *pst);
void f(struct Student *pst);

int main(void){
	struct Student st = {100, "韩绝", 22};
	strcpy(st.name , "韩绝哥");
	printf("%d  %s %d \n", st.sid, st.name, st.age); 
	
	struct Student * pst;
	 pst = &st;
	 pst ->sid = 99;  //等价于 (*pst).sid 等价于 st.sod
//	 pst  指向结构体的成员 sid 

	struct Student st1; //未赋值， st1存储的为垃圾数值
	g(&st1);
	f(&st1);
	 
}

void g(struct Student * pst){
	(*pst).sid = 1998;
	strcpy(pst->name, "赵哥");
	(*pst).age = 20; 
} 
void f(struct Student * pst){
	printf("\n 为您输出赵哥的信息： %d %s %d \n", pst->sid, pst->name, pst->age);
}

```



# 4.19	17点

## 



