# 4.17 15点数据结构

## 模块一 线性结构

![image-20230417150835574](数据结构笔记.assets/image-20230417150835574.png)

![image-20230417150939043](数据结构笔记.assets/image-20230417150939043.png)

- java中容器和数据结构**相关知识**：

  ​	Iterator接口、	Map、	哈希表



## 数据结构概述

- **定义：** 如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器

  ​		（内存）中，以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行相应操作，这个相应的操作称为算法。

  - 特定的数据类型： 个体如何存储
  - 特定的存储结构： 个体间的关系   



**数据结构**： 个体 + 个体的关系

**算法：** 对存储数据的操作

​		解题方法和步骤

## **衡量算法的标准** 

- 时间复杂度  （程序执行的次数, 运行所需步骤 ）
- 空间复杂度 （算法执行过程中所占用的最大内存）
- 难易程度
- 健壮性



**数据结构的地位**： 是软件中**最核心**的课程 

- 程序： 数据的存储 + 数据的操作 + 可以被计算机执行的语言



**预备知识** ： 指针  结构体  动态内存的分配与释放

- [ ] ![image-20230417165052668](数据结构笔记.assets/image-20230417165052668.png)

- **地址线：** 找到所要进行处理的地址 (地址范围和机器的位数有关系，2的n次方)
- **控制线：** 操作的范围， 只读/ 只写 / 读并写
- **数据线：** 传入数据的方向， a-b / b-a



 ![image-20230417165527094](数据结构笔记.assets/image-20230417165527094.png)

![image-20230417172752381](数据结构笔记.assets/image-20230417172752381.png)

##   一维整型数组

a[0]:  a数组名表示 数组内第一个元素，所占字节数的首地址，但是在调用或使用时，*a == a[0] 会自动截取整个元素（获取其全部字节数），最终显示出**整个元素**



在32位的操作系统中： 一个指针变量（任意类型）的地址所占为4个字节

​	指针变量只存储所指向数据类型的地址（n个字节） 所占字节数第一个字节（8位）的地址

​		当使用此地址进行引用时，指针会自动识别该数据类型提取整个数据



## 指针数组和数组指针的概念

**指针数组**：指针数组是一个数组，是指由指针构成的数组，在这个数组中的所有元素都是指针，每个指针**占用相同**的字节

**数组指针**：数组指针是一个指针，是指一个数组的指针，数组两字表示这个指针指向一个数组的首地址，并且这个**指针加1时移动**的位置是整个数组的长度



## 指向数组的指针代码块及理解

![image-20230417232020822](数据结构笔记.assets/image-20230417232020822.png)

![image-20230417232024013](数据结构笔记.assets/image-20230417232024013.png)

![image-20230417232757151](数据结构笔记.assets/image-20230417232757151.png)

​	**解决**: 内部的*号表示 获取整型数组第一个元素的地址，所以后面的+2，会**根据前面元素的类型** 变成加两个整型数据的字节数，所以变成第三个元素的地址，所以* ***内部**等于第三个元素的值

## 结构体的复习

```c++
#include<stdio.h>
#include<string.h>

struct Student{
	int sid;
	char name[200];
	int age;
};
//提前声明， main后定义了两个方法（在后面需要声明） 
void g(struct Student *pst);
void f(struct Student *pst);

int main(void){
	struct Student st = {100, "韩绝", 22};
	strcpy(st.name , "韩绝哥");
	printf("%d  %s %d \n", st.sid, st.name, st.age); 
	
	struct Student * pst;
	 pst = &st;
	 pst ->sid = 99;  //等价于 (*pst).sid 等价于 st.sod
//	 pst  指向结构体的成员 sid 

	struct Student st1; //未赋值， st1存储的为垃圾数值
	g(&st1);
	f(&st1);
	 
}

void g(struct Student * pst){
	(*pst).sid = 1998;
	strcpy(pst->name, "赵哥");
	(*pst).age = 20; 
} 
void f(struct Student * pst){
	printf("\n 为您输出赵哥的信息： %d %s %d \n", pst->sid, pst->name, pst->age);
}

```





# 4.18 	18：30

## 复习 malloc() 动态分配内存

 

​	

```C
#include<stdio.h>
#include<stdlib.h>
#include<malloc.h>
int main() {
	printf("请输入你要分配的整型数组长度： \n");
	int len ;
	scanf("%d", &len);

// 定义了一个整型指针  pArr, 其指向的为数组的第一元素
	int * pArr = (int*) malloc(sizeof(int) * len);
	for(int i=0; i< len; i++) {
		scanf(" %d", &pArr[i]);
	}

	for(int i=0; i<len; i++) {
		printf("数组中第%d个元素的值为：%d \n ",i+1, *(pArr+i));
	}
	free(pArr);
	return 0 ;
}

```

太久没写c语言： 在scanf中的输入时，填写了文本（“请输入第%d的数字”），导致在执行循环时，未报错，但是直接跳过输入的环节。

​	**scanf:** 内部只能存在占位符



# 4.19  中午  16点

## 结构体的使用-review

​		指向结构体的指针，不能直接.访问 ， 使用 **pst.age** ，来访问属性，会报错

​				如需使用: 必须先到达 地址 ,  （*p）.age ==  p->age

```C
#include<stdio.h>
#include<malloc.h>
#include<string.h>

struct Student{
	int age;
	char name[100];
};
struct Student *  CreateStudent();
void ShowStudent (struct Student* pst);

int main() {
	struct Student * ps;
	ps = CreateStudent();
	ShowStudent(ps);
	return 0;
}

struct Student *  CreateStudent() {
	struct Student * p = (struct Student*)malloc(sizeof(struct Student));

	p->age = 20;
	strcpy(p->name, "韩绝");
	return p;
}

void ShowStudent (struct Student* pst){
	printf("年龄为： %d, 姓名为 : %s", pst->age, pst->name);
}

#include<stdio.h>
#include<malloc.h>
#include<string.h>

struct Student{
	int age;
	char name[100];
};
struct Student *  CreateStudent();
void ShowStudent (struct Student* pst);

int main() {
	struct Student * ps;
	ps = CreateStudent();
	ShowStudent(ps);
	return 0;
}

struct Student *  CreateStudent() {
	struct Student * p = (struct Student*)malloc(sizeof(struct Student));

	p->age = 20;
	strcpy(p->name, "韩绝");
	return p;
}

void ShowStudent (struct Student* pst){
	printf("年龄为： %d, 姓名为 : %s", pst->age, pst->name);
}


```



## 模块1： 线性结构 （所有结点 由直线连接）

### 连续存储-【数组】

- ​	数组： 元素类型相等，大小相等



### 动态构造数组及数组内部方法（初始化、判断是否为空、元素遍历…）

```C
#include<stdio.h>
#include<malloc.h>
#include<stdbool.h>
#include <cstdlib>

struct Arr{
	int * pBase; //存储数组首元素的地址
	int len; // 数组容纳的最大元素的个数 
	int cnt; //当前数组有效元素个数 
//	int increment 自动增长因子， 拿空间换时间，提高效率 
// 举例： 插入1时会自动插入5的空间  需要用到动态扩充的知识 
};

void init_arr(struct Arr *pArr, int length);
bool is_empty(struct Arr * pArr);
void show_arr(struct Arr * pArr);

int main(){
	struct Arr arr;
	init_arr(&arr, 6); //将构造的数组 通过传地址 调用函数初始化 
	show_arr(&arr);
}

void init_arr(struct Arr *pArr, int length){
	pArr-> pBase = (int*) malloc (sizeof(int)* length);
		if(pArr->pBase == NULL){
			printf("报告赵哥，空间分配失败"); 
			exit(-1);
		}
	pArr->	len = length;
	pArr->  cnt = 0; 
}

bool is_empty(struct Arr * pArr){
	if(pArr-> cnt == NULL)
		return true;
	else
		return false;
} 

void show_arr(struct Arr * pArr){
	if(is_empty(pArr)){
		printf("数组元素个数为0，无法为您输出！ \n");
	}else{
		for(int i=0; i<(pArr->cnt); i++){
			printf("数组中第%d的元素为： %d", i+1, i); 
		}	
	}
	return ;
}


```



​	**exit(-1):  本程序终止**，需要导入头文件包： **#include <cstdlib>**		

​				课外知识： 终止： 终止不在继续		中止：可继续可终止



## C语言中 exit(0)  exit(非0) return区别

<img src="数据结构笔记.assets/image-20230420201613151.png" alt="image-20230420201613151" style="zoom: 67%;" />

<img src="数据结构笔记.assets/image-20230420201909252.png" alt="image-20230420201909252" style="zoom:67%;" />



### 指定数组下标 插入元素

![image-20230420231025921](数据结构笔记.assets/image-20230420231025921.png)

1.  确保插入时，数组元素容量>=1
2. 挪动时，从最后一个有效元素开始往右挪一位，直至将目标下标往右挪方可覆盖插入





