## 线性结构的两种常见应用之一： 队列

定义： 一种可以实现”先进先出“的存储结构 

​	无封口管道 （高压水流 ）（先进先出） 注入和流出 的方向 只能单一

<img src="数据结构笔记_续.assets/image-20230423230155820.png" alt="image-20230423230155820" style="zoom:80%;" />

<img src="数据结构笔记_续.assets/image-20230423230533479.png" alt="image-20230423230533479" style="zoom:80%;" />

### 分类： 链式队列和静态队列

队列具有两个指向（头指针指向： front  尾指针指向: rear）

![image-20230423230857723](数据结构笔记_续.assets/image-20230423230857723.png)



<img src="数据结构笔记_续.assets/image-20230423231728442.png" alt="image-20230423231728442" style="zoom:80%;" />

<img src="数据结构笔记_续.assets/image-20230423231748209.png" alt="image-20230423231748209" style="zoom:80%;" />

### 链式队列： 用链表实现

#### 静态队列： 用数组表示

静态队列通常都必须是循环队列



## 循环队列的讲解：

1. 静态队列为什么必须是循环队列
2. 循环队列需要几个参数来确定
3. 循环队列各个参数的含义
4. 循环队列 入队伪算法讲解
5. 循环队列 出队伪算法讲解
6. 如何判断循环队列是否为空
7. 如何判断循环队列是否已满

<img src="数据结构笔记_续.assets/image-20230423232756099.png" alt="image-20230423232756099" style="zoom:80%;" />



# 4.24  15：30

### 模运算的目的



<img src="数据结构笔记_续.assets/image-20230424122737227.png" alt="image-20230424122737227" style="zoom:80%;" />



### 循环队列元素的最大个数为： maxSize -1

<img src="数据结构笔记_续.assets/image-20230424161636399.png" alt="image-20230424161636399" style="zoom:80%;" />

<img src="数据结构笔记_续.assets/image-20230424161655957.png" alt="image-20230424161655957" style="zoom:80%;" />

<img src="数据结构笔记_续.assets/image-20230424161945549.png" alt="image-20230424161945549" style="zoom:80%;" />



循环队列初始化时： 队头指针和队尾指针所指向的位置为同个位置（**队列为空**）

队头和队尾指针不会固定，随着进队出队，指针也会进行移动

**队头指针**： front指针所指向位置为第一个元素的位置

**队尾指针** :  rear指针所指向的位置： 最后一个元素的下一个**可用**位置，待插入位置





## 循环队列讲解- 视频-理解

<img src="数据结构笔记_续.assets/image-20230424162750454.png" alt="image-20230424162750454" style="zoom:80%;" />

2-

- 队列初始化：  **front**和**rear**的值都是0
- 队列非空： **front**指向队列第一个元素   **rear**代表的为最后一个有效元素的下一个元素位置
- 队列空： **front**和**rear**值相同， 但不一定等于0

4-**入队伪算法**

-  将值存入r代表的位置： r= (r+1) %数组长度

5-**出队伪算法**

-  front = (front+1) /数组长度

6- **判断循环队列是否为空**

-  **rear== front **  所以 数组最大值： maxSize -1 ,   如果为maxSize时，rear == front 产生歧义

7-如何判断循环队列为满



**预备知识**： front值 可能比rear大 小 /相等， 无规律性

- 两种方式： 

- 1. 定义一个标识参数 （定义一个函数 来记录存储的个数）  	

- 2. **少用一个元素，** 设置存入存入元素的最大长度值为： maxSize -1  ： 

     （两元素紧挨着 且满足以下判断条件，则队列已满 ）

     **C语言伪算法**

     if ( (r+1)%数组长度 == f ) 已满 ； else  不满;	

     

### 循环队列 龟壳表示

![image-20230424165511828](数据结构笔记_续.assets/image-20230424165511828.png)

 

### 标识参数标志 实现循环队列已满

<img src="数据结构笔记_续.assets/image-20230424175847314.png" alt="image-20230424175847314" style="zoom:80%;" />

此标识参数- 代码相比于 少用一个数组元素的方法判断 是否满元素  较复杂

- 在定义循环结构体的时候： 定义了一个bool标识参数
  - 在初始格式化时，将 bool is_full定义为 false 
- 每次调用 入队方法时，都会进行判断 rear == front (指向是否相同)，重合定义真
- 每次调用 出队都将  is_full 定义为  false - 出队意味着至少空余一个位置



### 标识参数构建循环列表 - 遍历方法

<img src="数据结构笔记_续.assets/image-20230424201704830.png" alt="image-20230424201704830" style="zoom:50%;" />



### 循环队列— 使用数组容量为： maxSize -1 创建 

详情见 e_1 文件

<img src="数据结构笔记_续.assets/image-20230424193559803.png" alt="image-20230424193559803" style="zoom: 67%;" />

<img src="数据结构笔记_续.assets/image-20230424193455571.png" alt="image-20230424193455571" style="zoom: 50%;" />

主要用到的知识点为： 空闲一个数组元素空间，使得判断 数组容量满时可使用--

**(rear+1)% length == front**,  不需要同标识参数样 在结构体定义一个 **标识参数**



###  队列的具体应用

- ​	所有和时间有关的操作都-- 都有队列的痕迹



## 递归

​	定义：	一个函数直接或间接调用自己

<img src="数据结构笔记_续.assets/image-20230424205628944.png" alt="image-20230424205628944" style="zoom: 80%;" />



## 时间复杂度和空间复杂度

<img src="数据结构笔记_续.assets/image-20230424210024138.png" alt="image-20230424210024138" style="zoom: 80%;" />



## 栈帧-- 调用程序时所使用的一段空间

<img src="数据结构笔记_续.assets/image-20230424210428626.png" alt="image-20230424210428626" style="zoom:80%;" />

<img src="数据结构笔记_续.assets/image-20230424210904054.png" alt="image-20230424210904054" style="zoom:80%;" />



### 举例

1.  1+2+3+…100和
2. 求阶乘 
3. 汉诺塔

![image-20230424215128508](数据结构笔记_续.assets/image-20230424215128508.png)

<img src="数据结构笔记_续.assets/image-20230425134242260.png" alt="image-20230425134242260" style="zoom:80%;" />



## 递归- 函数的调用- 函数为什么可以调用自己

### 函数的调用

![image-20230425151307848](数据结构笔记_续.assets/image-20230425151307848-1682406790943-1.png)



# 4.25  15点

## 递归须满足的三个条件

-  可分解性： 大规模问题可分为小规模解决
- 分解后的问题 - -  规模不同但操作/求解思路相同
- 具有终止的条件，问题可分解至最简单的求解方式，可进行终止，不会陷入死循环



**vo**:

-  函数处理的数据规模必须在递减
- 递归必须得有一个明确的终止条件
- 这个转化必须是可解的

<img src="数据结构笔记_续.assets/image-20230425152753332.png" alt="image-20230425152753332" style="zoom:80%;" />



## 递归和循环的比较- 异同

<img src="数据结构笔记_续.assets/image-20230425152941650.png" alt="image-20230425152941650" style="zoom:67%;" />

### 循环和递归

递归： 易于理解 --  速度慢 --  存储空间大

循环： 不易理解 -- 速度快 -- 存储空间小 

<img src="数据结构笔记_续.assets/image-20230425154719887.png" alt="image-20230425154719887" style="zoom:80%;" />

<img src="数据结构笔记_续.assets/image-20230425154735229.png" alt="image-20230425154735229" style="zoom:80%;" />

 



## 汉诺塔

**伪算法**： 

<img src="数据结构笔记_续.assets/image-20230425155434473.png" alt="image-20230425155434473" style="zoom: 50%;" />

![image-20230425164427559](数据结构笔记_续.assets/image-20230425164427559.png)

理解： 柱子位置可变动--

**解题思路**

柱子位置  A B C ， B为辅助盘

 将A 上盘子 **n-1 个 先借助C 移到盘B** 

**第n个直接从A盘放入C盘**

再将盘B上的盘子全部挪动到C柱上



最大盘放入C盘 可**视为空盘： 因为放入不移动，且盘为最大**



将 （n-1） 盘 从 B柱 借用 A柱  移动到 C 柱

在B柱上的盘数为 n-1,  此时将B 柱的盘数视为当前的 n个

柱子位置重新变更为： B   A   C

B柱 的 n-1个盘  **借助 C 移到 A**

再将**第n个盘从 B柱 移动到 盘C**

再将 A柱上的盘 移动到 C



依次类推：

​	下次的柱子位置变为： 

A （存有 n-2个盆） B （空盘）  C（C柱此刻已放入 第N个盘 和 第N-1个盘，仍可视为空盘）

**最后**

​	盘为1 时直接放入 从当前的处于 位置  **盘移动**A柱（**A/B**都可） 直接放入C柱



总结： 

- 每次的挪动都是先挪n-1个到辅助柱（A/B 都可），再将第n个挪入 C柱，最后再将辅助柱上的盘子挪动到C柱

<img src="数据结构笔记_续.assets/image-20230425183500880.png" alt="image-20230425183500880" style="zoom: 67%;" />

执行一次 Hannoi（val-1,A,C, B ） , 内部递归很多次，最后返回到本程序时

已将指定的盘数放至柱子上完毕





### 递归的应用

​	树和森林的就是以递归的方式定义的

​	树和图、数学公式

<img src="数据结构笔记_续.assets/image-20230425185251765.png" alt="image-20230425185251765" style="zoom:80%;" />



## 线性结构复习

逻辑结构： 线性： 数组 链表  

- 栈（链表实现 ）和队列（数组实现）是一种特殊的线性结构 



 非线性（复杂）： 树 --  图



物理结构： 内存为线性一维， 生活问题大多数是多维的，将多维的转化为一维的，故复杂



## 非线性存储-- 树



### 树的定义



树的定义 

专业定义：

-  有且只有一个称为根的节点
  - 有若干互不相交的子树，这些子树本身也是一棵树 

通俗定义：

- 树是由节点和边组成
- 每个节点只有一个父节点，但可以有多个子节点
- 但有一个节点例外，该节点没有父节点，此节点称为根节点



专业术语

​	节点		父节点 		子节点

​	子孙		堂兄弟（上一层 同层的不同 父节点 下的 节点间关系）	 

深度： 从根节点到最底层节点的层数称之为深度

​					根节点是第一层

叶子节点： 没有子节点的节点

非终端节点： 实际就是非叶子节点     

度： 子节点的个数称为度

<img src="数据结构笔记_续.assets/image-20230425193054305.png" alt="image-20230425193054305" style="zoom:80%;" />



### 树的分类



一般树：任何一个节点的子节点的个数都不受限制

二叉树： 任意一个节点的子节点个数最多为2个，且子节点的位置不可更改（左子树 右子树顺序不可更换 ）  **有序树**



**二叉树分类**

- 一般二叉树： 树中每个节点的度数不超过2，即每个节点最多只有两个子节点。由于每个节点只有   			两个子节点，因此可以将它们称为左子树和右子树。

- 满二叉树： 在不增加树层树的前提下，无法再多添加一个节点的二叉树

- 完全二叉树： 如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就		是 完全二叉树



满二叉树是一种特殊的完全二叉树。任意一棵满二叉树都是完全二叉树（不砍去最右边开始连续的系节点），但不是所有完全二叉树都是满二叉树。

完全二叉树**包含**满二叉树： 完全二叉树 减去 最底层从最右边开始连续的节点（删除个数可以为**0**）



森林： n个互不相交的树的集合 （若干树合一起 ）



<img src="数据结构笔记_续.assets/image-20230425193139845.png" alt="image-20230425193139845" style="zoom:80%;" />



## 树的存储

### 二叉树的存储

**连续存储【完全二叉树】**



**数组存储**

存储时： 需将一般二叉树转化为 完全二叉树 （非线性 转化为 线性 以便还原）

​		虽然浪费空间，但是能逆推为原来 树的形状

优点： 查找某个节点的父节点和子节点（也包括判断有没有子节点）

缺点： 耗用内存空间过大

​		（人为规范 规则）先序遍历 中序遍历 后序遍历



**链式存储** （左右子节点 指针指向）

优点： 可存储一般二叉树，不会出现静态分配空间（数组创建存储填充完全二叉树）

缺点： 查找某个节点 较于 数组存储来说 较慢



### 一般树的存储

### 🧡❣❣   双亲表示法、孩子表示法和孩子兄弟表示法

**双亲表示法**

双亲表示法采用一组连续的空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲在结点中的位置。这种方式比较**容易找到双亲**，但是不容易找到孩子。

![image-20230425224418297](数据结构笔记_续.assets/image-20230425224418297.png)



**孩子表示法**

将节点的孩子节点用链表链接起来形成一个线性结构，**容易找到节点的孩子**，但不容易找到双亲

![image-20230425225556871](数据结构笔记_续.assets/image-20230425225556871.png)



**双亲孩子表示法**

同时能找到 其孩子和父亲



数组内： 每个元素包含 该节点的有效数据  第二个为父节点数组下标  第三个为指针域

双亲孩子表示法是一种树的存储结构

它将每个结点的孩子结点都用链表链接起来形成一个线性结构

对于含有 n 个结点的树来说，就会有 n 个单链表，将 n 个单链表的头指针存储在一个线性表中，这样的表示方法就是孩子表示法。

在双亲孩子表示法中，每个结点除了存储其孩子结点的指针外，还存储了其父亲结点的指针。这样，在查找某个结点的父亲结点时，只需要访问该结点的父亲指针即可  

![image-20230425232359548](数据结构笔记_续.assets/image-20230425232359548.png)



**二叉树表示法**

把一个普通 树转化成二叉树来存储

- ​	设法保证任意一个节点的
  - 左指针指向它的第一个孩子
  - 右指针指向它的下一个兄弟

只要能满足此条件，就可以把一个普通树转化为二叉树

一个普通树转化成的二叉树一定没有右子树

![image-20230425234325716](数据结构笔记_续.assets/image-20230425234325716.png)





## 森林	转化存储转换

<img src="数据结构笔记_续.assets/image-20230425235501964.png" alt="image-20230425235501964" style="zoom:150%;" />

**二叉树表示法**

将树当成其兄弟，左边孩子， 右边兄弟，转化二叉树 （生成的树没有右子树）





## 二叉树的遍历



### 二叉树的先序遍历